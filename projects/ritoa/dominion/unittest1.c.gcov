        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Author: Aaron Rito
        -:    3:Date: 10/29/18
        -:    4:Client: CS362 assignment 3
        -:    5:Project: unit test for "getCost"
        -:    6:Sources: CS362 class, https://github.com/caperren/Archives
        -:    7: */
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <assert.h>
        -:   13:#include "rngs.h"
        -:   14:#define TESTCARD "getCost"
        -:   15:void my_assert(int result);
        1:   16:int main(int argc, char** argv) {
        1:   17:    int seed = 1000;
        1:   18:    int numPlayers = 2;
        -:   19:    int player,i, j;
        -:   20:    struct gameState G;
        -:   21:    int temp_k[10];
        1:   22:    int k[10] = {adventurer, salvager, village, minion, steward, cutpurse,
        -:   23:                    sea_hag, tribute, smithy, council_room};
        1:   24:    printf("----------------- Testing Unit: %s ----------------\n", TESTCARD);
        1:   25:    initializeGame(numPlayers, k, seed, &G);
        3:   26:    for(player = 0; player < numPlayers; player++)
        -:   27:    {
        -:   28:        /* BOUNDRY GET*/
        -:   29:        // get opp players hand
        2:   30:        G.whoseTurn = player;            
        2:   31:        G.handCount[G.whoseTurn] = 5;
        -:   32:        int opp_player_cards;
        2:   33:        if (player == 0)
        -:   34:        {
        1:   35:            G.whoseTurn = player +1;            
        1:   36:            G.handCount[G.whoseTurn] = 5;
        1:   37:            opp_player_cards = numHandCards(&G);
        1:   38:            G.whoseTurn = player;
        -:   39:        }
        -:   40:        else
        -:   41:        {
        1:   42:            G.whoseTurn = player -1;            
        1:   43:            G.handCount[G.whoseTurn] = 5;
        1:   44:            opp_player_cards = numHandCards(&G);
        1:   45:            G.whoseTurn = player;
        -:   46:        }           
        -:   47:        // get kingdom supply
       22:   48:        for(i = 0; i < 10; i++)    
       20:   49:            temp_k[i] = supplyCount(k[i], &G);
        -:   50:        // get victory supply
        2:   51:        int estates = supplyCount(estate, &G);
        2:   52:        int duchys = supplyCount(duchy, &G);
        2:   53:        int provinces = supplyCount(province, &G);
        -:   54:        /* END BOUNDRY GET*/
        -:   55:        /* START RUN CARD*/ 
        -:   56:        int cardCost;
       56:   57:        for (int i = 0; i < 27; i++)
        -:   58:        {
       54:   59:            cardCost = getCost(i);           
       54:   60:            switch( i ) 
        -:   61:            {
        -:   62:                case curse:
        2:   63:                  my_assert(cardCost == 0);
        2:   64:                  break;
        -:   65:                case estate:
        2:   66:                  my_assert(cardCost == 2);
        2:   67:                  break;
        -:   68:                case duchy:
        2:   69:                  my_assert(cardCost == 5);
        2:   70:                  break;
        -:   71:                case province:
        2:   72:                  my_assert(cardCost == 8);
        2:   73:                  break;
        -:   74:                case copper:
        2:   75:                  my_assert(cardCost == 0);
        2:   76:                  break;
        -:   77:                case silver:
        2:   78:                  my_assert(cardCost == 3);
        2:   79:                  break;
        -:   80:                case gold:
        2:   81:                  my_assert(cardCost == 6);
        2:   82:                  break;
        -:   83:                case adventurer:   
        2:   84:                  my_assert(cardCost == 6);
        2:   85:                  break;
        -:   86:                case council_room:
        2:   87:                  my_assert(cardCost == 5);
        2:   88:                  break;
        -:   89:                case feast:
        2:   90:                  my_assert(cardCost == 4);
        2:   91:                  break;
        -:   92:                case gardens:
        2:   93:                  my_assert(cardCost == 4);
        2:   94:                  break;
        -:   95:                case mine:
        2:   96:                  my_assert(cardCost == 5);
        2:   97:                  break;
        -:   98:                case remodel:
        2:   99:                  my_assert(cardCost == 4);
        2:  100:                  break;
        -:  101:                case smithy:
        2:  102:                  my_assert(cardCost == 4);
        2:  103:                  break;
        -:  104:                case village:
        2:  105:                  my_assert(cardCost == 3);
        2:  106:                  break;
        -:  107:                case baron:
        2:  108:                  my_assert(cardCost == 4);
        2:  109:                  break;
        -:  110:                case great_hall:
        2:  111:                  my_assert(cardCost == 3);
        2:  112:                  break;
        -:  113:                case minion:
        2:  114:                  my_assert(cardCost == 5);
        2:  115:                  break;
        -:  116:                case steward:
        2:  117:                  my_assert(cardCost == 3);
        2:  118:                  break;
        -:  119:                case tribute:
        2:  120:                  my_assert(cardCost == 5);
        2:  121:                  break;
        -:  122:                case ambassador:
        2:  123:                  my_assert(cardCost == 3);
        2:  124:                  break;
        -:  125:                case cutpurse:
        2:  126:                  my_assert(cardCost == 4);
        2:  127:                  break;
        -:  128:                case embargo: 
        2:  129:                  my_assert(cardCost == 2);
        2:  130:                  break;
        -:  131:                case outpost:
        2:  132:                  my_assert(cardCost == 5);
        2:  133:                  break;
        -:  134:                case salvager:
        2:  135:                  my_assert(cardCost == 4);
        2:  136:                  break;
        -:  137:                case sea_hag:
        2:  138:                  my_assert(cardCost == 4);
        2:  139:                  break;
        -:  140:                case treasure_map:
        2:  141:                  my_assert(cardCost == 4);
        2:  142:                  break;
    #####:  143:                default: return -1;
        -:  144:            }
        -:  145:        }
        -:  146:        /* END RUN CARD CHECK*/
        -:  147:        /* BOUNDRY CHECKS*/
        -:  148:        // ensure kingdom and victory piles the same
       22:  149:        for(j = 0; j < 10; j++)    
       20:  150:            my_assert(temp_k[j] == supplyCount(k[j], &G));
        2:  151:        my_assert(estates == supplyCount(estate, &G));
        2:  152:        my_assert(duchys == supplyCount(duchy, &G));
        2:  153:        my_assert(provinces == supplyCount(province, &G)); 
        -:  154:        // check player state
        2:  155:        if (player == 0)
        -:  156:        {
        1:  157:            G.whoseTurn = player +1;            
        1:  158:            G.handCount[G.whoseTurn] = 5;
        1:  159:            opp_player_cards = numHandCards(&G);
        -:  160:        }
        -:  161:        else
        -:  162:        {
        1:  163:            G.whoseTurn = player -1;            
        1:  164:            G.handCount[G.whoseTurn] = 5;
        1:  165:            my_assert(opp_player_cards = numHandCards(&G));
        -:  166:        }
        -:  167:    }
        -:  168:}
       81:  169:void my_assert(int result){
       81:  170:    if (result) 
       81:  171:        printf("TEST PASSED!\n");
        -:  172:    else 
    #####:  173:        printf("TEST FAILED!\n");
       81:  174:}
