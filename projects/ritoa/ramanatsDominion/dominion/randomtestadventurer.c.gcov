        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/*
        -:    2:Author: Aaron Rito
        -:    3:Date: 10/29/18
        -:    4:Client: CS362 assignment 3
        -:    5:Project: unit test for "adventurer"
        -:    6:Source: CS362 class
        -:    7: */
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include "rngs.h"
        -:   13:#include <stdlib.h>
        -:   14:#define TESTCARD "Adventurer"
        -:   15:void my_assert(int result);
        -:   16:int test_passed = 0;
        -:   17:int test_failed = 0;
function main called 2 returned 100% blocks executed 100%
        2:   18:int main(int argc, char** argv) {
        2:   19:    int seed = MAX_HAND-5;
        2:   20:    SelectStream(1);
call    0 returned 100%
        2:   21:    PutSeed(seed);
call    0 returned 100%
        2:   22:    int numPlayers = 2;
        -:   23:    int player,h, i, j;
        -:   24:    struct gameState G;
        -:   25:    int temp_k[10];
        2:   26:    int k[10] = {adventurer, salvager, village, minion, steward, cutpurse,
        -:   27:                    sea_hag, tribute, smithy, council_room};
        2:   28:    printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        2:   29:    initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        2:   30:    int num_of_tests = 10000;
    20002:   31:    for(h = 0; h < num_of_tests; h++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   32:    {
    60000:   33:        for(player = 0; player < numPlayers; player++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   34:        {
        -:   35:            /* BOUNDRY GET*/
        -:   36:            // get opp players hand
    40000:   37:            int random_hand = Random();
call    0 returned 100%
    40000:   38:            G.whoseTurn = player;            
    40000:   39:            G.handCount[G.whoseTurn] = random_hand;
        -:   40:            int opp_player_cards;
    40000:   41:            if (player == 0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   42:            {
    20000:   43:                G.whoseTurn = player +1;            
    20000:   44:                G.handCount[G.whoseTurn] = random_hand;
    20000:   45:                opp_player_cards = numHandCards(&G);
call    0 returned 100%
    20000:   46:                G.whoseTurn = player;
        -:   47:            }
        -:   48:            else
        -:   49:            {
    20000:   50:                G.whoseTurn = player -1;            
    20000:   51:                G.handCount[G.whoseTurn] = random_hand;
    20000:   52:                opp_player_cards = numHandCards(&G);
call    0 returned 100%
    20000:   53:                G.whoseTurn = player;
        -:   54:            }          
        -:   55:            // get kingdom supply
   440000:   56:            for(i = 0; i < 10; i++)    
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
   400000:   57:                temp_k[i] = supplyCount(k[i], &G);
call    0 returned 100%
        -:   58:            // get victory supply
    40000:   59:            int estates = supplyCount(estate, &G);
call    0 returned 100%
    40000:   60:            int duchys = supplyCount(duchy, &G);
call    0 returned 100%
    40000:   61:            int provinces = supplyCount(province, &G);
call    0 returned 100%
        -:   62:            /* END BOUNDRY GET*/
        -:   63:            /* START RUN CARD*/ 
    40000:   64:            int num_of_cards = numHandCards(&G);
call    0 returned 100%
    40000:   65:            int money = G.coins;
    40000:   66:            rAdventurer(&G);
call    0 returned 100%
    40000:   67:            my_assert((numHandCards(&G) == num_of_cards + 1 )&& (G.coins <= money));
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:   68:            /* END RUN CARD CHECK*/
        -:   69:            /* BOUNDRY CHECKS*/
        -:   70:            // ensure kingdom and victory piles the same
   440000:   71:            for(j = 0; j < 10; j++)    
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
   400000:   72:                my_assert(temp_k[j] == supplyCount(k[j], &G));
call    0 returned 100%
call    1 returned 100%
    40000:   73:            my_assert(estates == supplyCount(estate, &G));
call    0 returned 100%
call    1 returned 100%
    40000:   74:            my_assert(duchys == supplyCount(duchy, &G));
call    0 returned 100%
call    1 returned 100%
    40000:   75:            my_assert(provinces == supplyCount(province, &G)); 
call    0 returned 100%
call    1 returned 100%
        -:   76:            // check player state
    40000:   77:            if (player == 0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   78:            {
    20000:   79:                G.whoseTurn = player +1;            
    20000:   80:                G.handCount[G.whoseTurn] = random_hand;
    20000:   81:                opp_player_cards = numHandCards(&G);
call    0 returned 100%
        -:   82:            }
        -:   83:            else
        -:   84:            {
    20000:   85:                G.whoseTurn = player -1;            
    20000:   86:                G.handCount[G.whoseTurn] = random_hand;
    20000:   87:                my_assert(opp_player_cards = numHandCards(&G));
call    0 returned 100%
call    1 returned 100%
        -:   88:            }
        -:   89:        }
        -:   90:    }
        2:   91:    printf("%d tests passed.\n", test_passed);
call    0 returned 100%
        2:   92:    printf("%d tests failed.\n", test_failed);
call    0 returned 100%
        -:   93:}
function my_assert called 580000 returned 100% blocks executed 100%
   580000:   94:void my_assert(int result) {
   580000:   95:    if (result) 
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
   520052:   96:        test_passed++;
        -:   97:    else
    59948:   98:        test_failed++;         
   580000:   99:}
